## 최장 증가 수열(LIS)

- 길이가 최대인 정렬된 부분수열
- ex) [7,2,3,8,4,5] -> [2,3,4,5] => 답은 4
- 구현 방법
  1. DP : O(n²)
  2. 이분탐색 : O(nlogn)

-------

x = 수열 A의 크기
arr = 수열 A를 이루고 있는 A(i)를 담은 배열
dp = 가장 긴 증가하는 부분 수열을 저장할 배열 

**bisect.bisect_left(arr, x): arr가 정렬되어있다는 가정하에 x값이 들어갈 위치 반환**

 \1. dp를 arr[0]으로 초기화한다.

\2. 현재 위치(i)가 이전 위치의 원소들보다 크면 dp에 추가한다.

\3. 현재 위치(i)가 이전 위치의 원소보다 작거나 같으면, bisect.bisect_left로 이전 위치의 원소 중 가장 큰 원소의 index값을 구한다. 그리고 dp의 index 원소를 arr[i]로 바꿔준다.

 \4. dp의 길이를 출력한다.

정답은 4가 된다.

### Reference

https://hyun-am-coding.tistory.com/entry/%EC%B5%9C%EC%9E%A5-%EC%A6%9D%EA%B0%80-%EB%B6%80%EB%B6%84-%EC%88%98%EC%97%B4LIS-%EA%B0%9C%EB%85%90



## 최소 공통 조상(LCA)

- 두 노드의 공통된 조상 중 가장 가까운 조상 찾기
- 동작 순서
  1. 모든 노드 깊이 계산(dfs활용)
  2. 두 노드 확인
     1. 두 노드 깊이 동일하도록 거슬러 올라감
     2. 부모 같아질때까지 반복적으로 부모방향으로 거슬러 올라감
  3. 모든 LCA(a, b)연산에 대해 반복
- 시간복잡도
  - 최악 : O(N) - 한쪽 치우친 노드
  - 모든 쿼리 (M)에 대해서 시간복잡도 O(NM)
- 개선
  - 동작 순서에서 거슬러 올라갈때 2^n으로 탐색하도록 함
  - O(log n)



## 동적 계획법(DP)

- 구현 방식
  - bottom-up (반복문)
  - top-down (재귀함수)
- 장점 : 점화식 이해하기 쉬움 / 시간,메모리 줄일수있음

- 1. memoization

  - 중복되는 계산은 한번만 계산 후 메모 ⇒ 하향식접근, **재귀**
  - 필요없는 계산 안해도 된다는 장점.
  - 재귀로 인해 호출 stack계속 쌓이면 오류날수있음

- 2.tabulation

  - 상향식 접근, **반복문**, table방식으로 정리
  - 필요없는 계산이 많아짐.
  - 중복되는 계산을 없애준다는 공통점





## 다익스트라 알고리즘

특정한 정점에서 다른 모든 정점으로 가는 최단 경로를 기록

- 최단 거리 저장
- 정점 방문 여부 저장
- 시간복잡도 : 인접행렬 O(n²), 인접리스트 O(nlogn)

https://brownbears.tistory.com/554





# 비트마스크

정수의 이진수 표현을 자료구조로 쓰는 기법

- 장점

  1) 빠른 수행시간 : O(1), 비트의 개수만큼 원소를 다룰 수 있기 때문에 연산 횟수 클수록 차이 커짐.
  2) 짧은 코드 : 집합 연산자들을 비트연산자로 간결한 작성 가능
  3) 적은 메모리 사용량 : 10bit 이진수 하나로 2^10가지의 경우 표현 가능 -> 메모리 측면 효율적
     더 많은 데이터 미리 계산해서 저장 가능한 장점.

- 연산자

  1. AND : 둘 다
  2. OR : 둘 중 하나라도
  3. XOR : 둘중 하나만 1이면 1, 둘다 1/0이면 0
  4. NOT : 반대의 경우
  5. shift : 왼쪽(<<)/오른쪽(>>) 이동

- 연산자 활용

  1. 원소 추가  : n=3일때 1을 3만큼 왼쪽으로 밀어주면 1000, 0010 OR 1000 = 1010

     ```python
     n = 3
     print(bin(0b0010 | (1 << n)))  # 0b1010
     ```

  2. 원소 삭제  : n=3일때 1을 3만큼 왼쪽으로 밀어주면 1000, (~1000) = 0111, 0111 AND 1000 = 0010

     ```python
     n = 3
     print(bin(0b0010 & ~(1 << n)))  # 0b0010
     ```

  3. 원소 조회  : n=3일때 1을 3만큼 왼쪽으로 밀어주면 1000, 1010 AND 1000 = 1000

     ```python
     n = 3
     print(bin(0b1010 & (1 << n)))  # 0b1000
     ```

  4. 원소 토글(XOR)  : n=3일때 1을 3만큼 왼쪽으로 밀어주면 1000, 1010 XOR 1000 = 0010

     ```python
     n = 3
     print(bin(0b1010 ^ (1 << n)))  # 0b10
     ```

     

- 주의점

  1. 비교 연산자보다 낮은 우선순위
  2. 오버플로우(overflow)

- 집합 구현

  하나의 비트가 하나의 원소로, 비트가 켜져있으면 집합에 포함, 꺼져있으면 불포함의 의미.

  N비트 정수 변수로 N개의 원소 갖는 집합의 부분집합 표현 가능

  0-9일 경우, 공집합 : 0, 전체집합 (1<<10) - 1

  ex) {a,b,c,d} 총 4개의 원소에서 존재하면 1, 아니면 0
  {a}라는 부분집합은 1000(2) = 8 로 표현, {b,c} 는 0110(2) = 6으로 표현

  

  <연관문제>

  이진수 연산 : https://www.acmicpc.net/problem/12813

  집합 : https://www.acmicpc.net/problem/11723

  --------

  ### Reference

  https://studyandwrite.tistory.com/325

  https://shoark7.github.io/programming/algorithm/introduction-to-tsp-and-solve-with-exhasutive-search#3b

  