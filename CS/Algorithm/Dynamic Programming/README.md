## 최장 증가 수열(LIS)

- 길이가 최대인 정렬된 부분수열
- ex) [7,2,3,8,4,5] -> [2,3,4,5] => 답은 4
- 구현 방법
  1. DP : O(n²)
  2. 이분탐색 : O(nlogn)

-------

x = 수열 A의 크기
arr = 수열 A를 이루고 있는 A(i)를 담은 배열
dp = 가장 긴 증가하는 부분 수열을 저장할 배열 

**bisect.bisect_left(arr, x): arr가 정렬되어있다는 가정하에 x값이 들어갈 위치 반환**

 \1. dp를 arr[0]으로 초기화한다.

\2. 현재 위치(i)가 이전 위치의 원소들보다 크면 dp에 추가한다.

\3. 현재 위치(i)가 이전 위치의 원소보다 작거나 같으면, bisect.bisect_left로 이전 위치의 원소 중 가장 큰 원소의 index값을 구한다. 그리고 dp의 index 원소를 arr[i]로 바꿔준다.

 \4. dp의 길이를 출력한다.

정답은 4가 된다.

### Reference

https://hyun-am-coding.tistory.com/entry/%EC%B5%9C%EC%9E%A5-%EC%A6%9D%EA%B0%80-%EB%B6%80%EB%B6%84-%EC%88%98%EC%97%B4LIS-%EA%B0%9C%EB%85%90



## 최소 공통 조상(LCA)

- 두 노드의 공통된 조상 중 가장 가까운 조상 찾기
- 동작 순서
  1. 모든 노드 깊이 계산(dfs활용)
  2. 두 노드 확인
     1. 두 노드 깊이 동일하도록 거슬러 올라감
     2. 부모 같아질때까지 반복적으로 부모방향으로 거슬러 올라감
  3. 모든 LCA(a, b)연산에 대해 반복
- 시간복잡도
  - 최악 : O(N) - 한쪽 치우친 노드
  - 모든 쿼리 (M)에 대해서 시간복잡도 O(NM)
- 개선
  - 동작 순서에서 거슬러 올라갈때 2^n으로 탐색하도록 함
  - O(log n)



## 동적 계획법(DP)

- 구현 방식
  - bottom-up (반복문)
  - top-down (재귀함수)
- 장점 : 점화식 이해하기 쉬움 / 시간,메모리 줄일수있음

- 1. memoization

  - 중복되는 계산은 한번만 계산 후 메모 ⇒ 하향식접근, **재귀**
  - 필요없는 계산 안해도 된다는 장점.
  - 재귀로 인해 호출 stack계속 쌓이면 오류날수있음

- 2.tabulation

  - 상향식 접근, **반복문**, table방식으로 정리
  - 필요없는 계산이 많아짐.
  - 중복되는 계산을 없애준다는 공통점





## 다익스트라 알고리즘

특정한 정점에서 다른 모든 정점으로 가는 최단 경로를 기록

- 최단 거리 저장
- 정점 방문 여부 저장
- 시간복잡도 : 인접행렬 O(n²), 인접리스트 O(nlogn)

https://brownbears.tistory.com/554