# Database

1. [키](#key)
2. [SQL JOIN](#sql-join)
3. [SQL vs NoSQL](#sql-vs-nosql)
4. [정규화 vs 반정규화](#정규화-vs-반정규화)
5. [Transaction](#transaction)


<br/>

## Key

데이터를 식별하고 원하는 값을 얻을 수 있다. 특정 데이터를 검색하거나 정렬할 수 있는 속성 값. 중복되지 않게 이상 현상(Anomaly : 삽입 이상, 삭제 이상, 수정 이상 등)을 방지한다.

- 유일성 : 하나의 키 값으로 하나의 튜플 식별된다.
- 최소성 : 유일성이 유지되는 최소의 속성으로 구성된다.

### 01. Key 종류

![db_key](https://user-images.githubusercontent.com/33693066/143180415-1f41a9ea-dad0-43dd-a819-03fcf4494987.PNG)

- **슈퍼키(Super Key)** : 유일성을 만족하며 한 개 이상의 속성들의 집합, 최소성을 만족하지 못하며 후보키와 기본키가 속한다.
- **후보키(Candidate Key)** : 유일성과 최소성을 만족하는 키, 기본키와 대체키의 집합으로 여기서 주 식별자로 선택된 값이 기본키이다.
- **기본키(Primary Key)** : 유일성과 최소성을 만족하며 후보키에서 대표로 지정된 키. Null 값이나 중복된 값을 가질 수 없다.
- **외래키(Foreign Key)** : 두 개 이상의 릴레이션에서 어떤 릴레이션의 기본키를 참조하는 경우 외래키라고 하며, 외래키로 지정되면 참조 릴레이션의 기본키에 없는 값을 사용할 수 없다. (⇒ 참조 무결성 제약을 만족해야한다.)
- **부분키(Partition Key)** : 약한 개체를 유일하고 최소로 구분해 낼 수 있는 키.(구별자)

<br/>

> <*>면접 질문목록
>
> 스키마, DBMS 종류, Nosql, 크롤링데이터, 트랜잭션 데드락 핸들링, ACID(원자성,...) 컨트롤, 정규화 부분

<br/>

### 02. 이상(Anomaly)

- 삽입 이상
  
    데이터를 삽입할 때 불필요한 데이터를 추가해야하는 현상
    
- 삭제 이상
  
    한 튜플을 삭제할 때 다른 값이 함께 삭제되는 현상
    
- 갱신 이상
  
    갱신이 필요한 튜플을 모두 변경하지 않아서 생기는 이상 현상
    
    <br/>

### *  용어 정리

| 파일 시스템 | DB 모델링 [단위] | 관계형 DB |
| --- | --- | --- |
| File | Entity | Table |
| Record | Tuple [cadinality] | Row |
| Field | Attribute [degree] | Column |
| Key | Identifier | Primary Key/Unique |

Domain : 속성 값에 들어갈 수 있는 값의 범위

<br/>

### 03. 무결성 제약(Integrity Constraint)

- 개체 무결성 제약
  
    기본키를 구성하는 속성 값에는 Null값이나 중복 값을 가지지 못한다.
    
- 참조 무결성
  
    릴레이션 R1에 저장된 튜플이 다른 릴레이션(R0)에 있는 튜플을 참조하려면 해당 릴레이션(R0)에 반드시 튜플이 존재해야한다. 외래키는 참조 릴레이션의 기본키로 존재하고 두 키(외래키, 참조된 기본키) 간에 도메인과 속성 갯수 또한 일치해야 한다.
    
- 도메인 무결성
  
    주어진 속성 값이 해당 속성에 정의된 도메인에 속해야한다.
    
    <br/><br/>

## SQL JOIN

두 개의 릴레이션을 공통 속성을 기준으로 묶어 새로운 릴레이션을 생성하는 연산

(예시는 [링크](https://github.com/OnewayYoun/ps-cs-project-study/blob/main/CS/Database/SQL%20JOIN%20%EC%98%88%EC%8B%9C.md) 참조)

- 외부 조인(Outer Join)
  
    내부 조인을 확장한 개념으로 릴레이션에 있는 튜플에 조인할 상대 릴레이션 튜플이 대응되지 않으면 Null 튜플로 생성한다. 기준이 되는 릴레이션은 left / right / 전체로 지정할 수 있다.
    
    좌측을 지정한 경우 먼저 나오는 릴레이션 튜플을 모두 활용, 우측은 이후에 나온 릴레이션 튜플을 기준으로 새로운 릴레이션을 생성한다.
    
- 내부 조인(Inner Join)
  
    두 릴레이션의 공통된 값을 이용해 모두 존재하는 데이터만 추출해 생성하는 방법

<br/>

## SQL vs NoSQL

|           | SQL DB                                                       | NoSQL DB                                                     |
| --------- | :----------------------------------------------------------- | ------------------------------------------------------------ |
| 정의      | **RDBMS**(관계형 데이터베이스 관리 시스템)의 데이터를 관리하기 위해 설계된 프로그래밍 언어 | **비관계형** 형식의 데이터를 관리하는 방법을 제공하는 데이터베이스 |
| 특징      | 1. 정해진 데이터 스키마에 따라 테이블에 저장됨.<br />2. 관계를 통해 여러 테이블에 분산됨.<br />3. 조인(JOIN)<br /> | 1. Document 구조<br />2. 다른 구조의 데이터를 같은 컬렉션에 추가 가능함.<br />3. 조인(JOIN) 개념 없음.<br />4. 수평적 확장(서버 추가로 DB 분산시킴) |
| 장점      | - 명확히 정의된 스키마<br />- 데이터 무결성 보장<br />- 데이터를 중복없이 한번만 저장함. | - 스키마 없어 유연함.<br />- 데이터는 애플리케이션이 필요로 하는 형식으로 저장됨.<br />- 수직/수평적 확장 가능 -> 모든 r/w 요청 가능 |
| 단점      | - 덜 유연함.<br />- 관계로 인해 조인문 많은 복잡한 쿼리 발생 가능.<br />- 수직적 확장 | - 유연성으로 인해 데이터 구조 결정 미루게 됨.<br />- 데이터 중복 계속 업데이트 필요함.<br />- 여러 컬렉션에 데이터가 중복되어 있으므로 수정 시 모든 컬렉션에서 수행해야 함. |
| 속성      | **ACID properties**<br />- *Atomicity(원자성)* : 트랜잭션의 작업이 부분적으로 실행되거나 중단되지 않는 것을 보장하는 것이다. (불가능한 최소의 단위인 하나의 원자처럼 동작한다는 의미이다.) <br />- *Consistency(일관성)* : 미리 정의된 규칙에서만 수정이 가능한 특성을 의미한다. (숫자 컬럼에 문자열값이 저장이 안되도록 보장한다.)  <br />- *Isolation(고립성)* : 트랜잭션 수행시 다른 트랜잭션의 작업이 끼어들지 못하도록 보장하는 것이다. <br />- *Durability(영구성)* : 성공적으로 수행된 트랜잭션은 영원히 반영이 되는 것을 의미한다. (한번 반영(commit)된 트랜젝션의 내용은 영원히 적용된다.) | **CAP theorem**<br />(오직 2가지만 만족 가능)<br />- *Consistency (일관성)* : 모든 요청은 최신 데이터 또는 에러를 응답받는다. (DB가 3개로 분산되었다고 가정할 때, 하나의 특정 DB의 데이터가 수정되면 나머지 2개의 DB에서도 수정된 데이터를 응답받아야 한다.) <br />- *Availability (가용성)* : 모든 요청은 정상 응답을 받는다. (특정 DB가 장애가 나도 서비스가 가능해야 한다.) <br />- *Partitions Tolerance (분리 내구성)* : DB간 통신이 실패하는 경우라도 시스템은 정상 동작 한다. |
| 사용 예시 | - 데이터가 자주 변경되는 애플리케이션<br />- 변경 예정 없고 스키마 명확해야 하는 경우 | - 정확한 데이터 구조 모르거나 변경/확장 필요할 때<br />- 자주 읽기를 실행하나, 데이터 변경 자주 없을 경우<br />- 막대한 양의 데이터 다뤄야 하는 경우(db 수평적 확대) |

<br/>

## 정규화 vs 반정규화

### 01. 정규화 *Normalization*

중복을 최소화하도록 설계된 데이터베이스

- 원칙

  - 데이터의 중복성이 감소

  - 정보의 무손실 표현 → 하나의 스키마를 다른 스키마로 변환할 때 정보의 손실이 있어서는 안 된다.

  - 분리의 원칙 → 하나의 독립된 관계성은 하나의 독립된 릴레이션으로 분리시켜 표현해야 한다.

- 장/단점

  | 장점                                                         | 단점                                                         |
  | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | - 이상 현상 해결<br />- 저장 공간의 최소화 가능<br />- 데이터 삽입 시 릴레이션 재구성의 필요성 감소<br />- 데이터 구조의 안정성 및 무결성 유지 | - 릴레이션 분해로 연산 증가해 응답시간 느려질 수 있음 <br />→ *"반정규화로 성능 향상"* |

  

##### 정규화 과정
![norm](https://user-images.githubusercontent.com/33693066/143280917-1fe16959-0786-47aa-991d-90adbad1e20a.PNG)

(예제 설명은 [링크1](https://chankim.tistory.com/9), [링크2](https://velog.io/@bsjp400/Database-DB-%EC%A0%95%EA%B7%9C%ED%99%94-%EB%B9%84%EC%A0%95%EA%B7%9C%ED%99%94%EB%9E%80) 참고)

1. **1NF**

   테이블에 각 도메인은 원자성을 가진다. (각 셀이 더 작게 나눌 수 없는 단일값을 가진다.)

2. **2NF**

   1NF 충족 + 테이블의 모든 컬럼이 완전 함수 종속을 만족(기본키가 아닌 모든 속성이 기본키에 완전 함수 종속)

   > - 완전 함수 종속 : 기본키 {x1, x2, x3}(결정자) 모두에 의해서 Y(종속자) 값이 결정될 경우
   > - 부분 함수적 종속 : 기본키 {x1, x2, x3} 중 {x1}에 의해서만 Y값이 결정될 경우
   > - 이행적 함수적 종속 : X → Y이고 Y → Z 는 X → Z이다.
   > - 다치 종속 : (X, Z)에 대응되는 Y의 집합이 X에만 종속되고 Z에는 독립적이면 Y는 X에 다치 종속, X ↠Y

3. **3NF**

   2NF 충족 + 모든 속성이 기본키(복합키)에 이행적 함수 종속이 되지 않아야 한다.(기본키가 아닌 속성들은 기본키에만 의존한다.)

   - 3NF 충족하도록 변경하려면 (X → Y), (Y → Z) 테이블로 분리하면 된다.

4. **BCNF**

   BCNF는 3NF를 만족하면서 함수 종속성 X->Y가 성립할 때 모든 결정자 X가 후보키인 정규형(모든 결정자가 후보키 집합에 속한 정규형)

   

<br/>

### 02. 반정규화(비정규화) *Denormalization*

읽기 성능 향상을 위해 설계된 데이터베이스.

읽기 작업이 많이 필요한 성능문제가 있는 테이블 때문.

시스템의 성능 향상, 개발 및 운영의 편의성 등을 위해 정규화된 데이터 모델을 통합, 중복, 분리하는 과정으로, **의도적으로 정규화 원칙을 위배하는 행위**

- 대상

  - 디스크 I/O 량이 많아서 조회 시 성능이 저하될 때.
  - 테이블끼리의 경로가 너무 멀어 조인으로 인한 성능 저하가 예상될 때
  - 칼럼을 계산하여 조회할 때 성능이 저하될 것이 예상될 때

- 장단점

  | 장점                                                         | 단점--                                                       |
  | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | - 빠른 데이터 조회→ 조인 비용이 줄어들기 때문<br />- 살펴볼 테이블이 줄어들기 때문에 데이터 조회 쿼리가 간단해짐→ 따라서 버그 발생 가능성도 줄어든다 | - 데이터 갱신이나 삽입 비용이 높음<br />- 데이터 갱신 또는 삽입 코드를 작성하기 어려워짐<br />- 데이터를 중복하여 저장하므로 더 많은 저장 공간이 필요<br />- 데이터 간의 일관성 손상 가능 |

- 주의점

  - 과도한 적용은 데이터 무결성이 깨질 수 있다.
  - 응답 시간 늦어질 수 있다.
  - 저장공간 효율 감소
  - 유지보수 어려움.

<br/>

## Transaction

- 데이터베이스의 상태를 변화시키기 위해 수행하는 작업 단위.

- Sql(select, insert, delete, update)로 데이터베이스를 접근하는 것을 의미.

- 데이터베이스에서 병행 제어 및 회복 작업 시 처리되는 작업의 논리적 단위.

- 특징

  - 원자성(**A**tomicity) : 트랜잭션이 DB에 모두 반영되거나, 혹은 전혀 반영되지 않아야 된다.
  - 일관성(**C**onsistency) : 트랜잭션의 작업 처리 결과는 항상 일관성 있어야 한다.
  - 독립성(**I**solation) : 둘 이상의 트랜잭션이 동시에 병행 실행되고 있을 때, 어떤 트랜잭션도 다른 트랜잭션 연산에 끼어들 수 없다.
  - 지속성(**D**urability) : 트랜잭션이 성공적으로 완료되었으면, 결과는 영구적으로 반영되어야 한다.

- 연산

  - Commit : 한개의 트랜잭션 작업이 성공적으로 끝났고 db가 다시 일관된 상태에 있음을 알리는 연산

  - Rollback : 트랜잭션이 비정상적 종료로 일관성 깨짐. 연산을 취소하는 연산. 트랜잭션을 재시작하거나 폐기함.


- > *트랜잭션 사이즈가 클수록 db커넥션 풀을 점유하는 것이고 단위가 클수록 점유시간 길어지고 다른 트랜잭션이 접근을 못하는 단점*

- 상태

  - 활동(Active) : 트랜잭션이 실행중인 상태

  - 실패(Failed) : 트랜잭션 실행에 오류가 발생하여 중단된 상태

  - 철회(Aborted) : 트랜잭션이 비정상적으로 종료되어 Rollback 연산을 수행한 상태

  - 부분 완료(Partially Committed) : 트랜잭션의 마지막 연산까지 실행했지만, Commit 연산이 실행되기 직전의 상태

  - 완료(Committed) : 트랜잭션이 성공적으로 종료되어 Commit 연산을 실행한 후의 상태

    <br/>

    

### 01. 병행제어(Concurrency Control)

- Lock : 데이터 일관성 보장하기 위한 방법, 동시성 제어하기 위한 기능.
  - Shared Lock(공유 락) : 읽을 때 사용
  - Exclusive Lock(배타적 락) : 변경할 때 사용

- 병행 : 매우 빠르게 여러 트랜잭션 사이 이동하면서 조금씩 처리 수행하는 방식
- 문제점
  1. 갱신 분실(Lost Update) : 같은 데이터에 대해 둘 이상의 트랜잭션이 동시에 갱신할 때, 갱신 결과 일부가 없어지는 현상.
  2. 모순성(Inconsistency) : 하나의 트랜잭션이 여러 데이터 갱신 연산을 수행할 때, 일관성 없는 상태의 데이터베이스에서 데이터를 가져옴으로써 데이터의 불일치가 발생하는 것.
  3. 연쇄 복귀 (Cascading Rollback) : 병행 수행되던 둘 이상의 트랜잭션 중 어느 한 트랜잭션에 오류가 발생하여 Rollback 하는 경우 다른 트랜잭션들도 함께 Rollback 되는 현상.
  4. 비완료 의존성 (uncommitted Dependency) : 하나의 트랜잭션 수행이 실패한 후 회복하기 전에 다른 트랜잭션이 실패한 갱신 결과를 참조하는 현상.

- 병행 제어 기법

  1. 로킹(Locking)

     트랜잭션이 접근하려는 데이터를 다른 트랜잭션이 접근 못하도록 잠그는 기법.

     - 상보 배제 기능 제공.

     - 잠금 설정한 트랜잭션이 해제할때까지 데이터 독점적 사용 가능

     - 로킹 단위가 클수록 병행 제어가 단순해지고 관리하기가 편하지만 병행성 수준이 낮아진다.

       로킹 단위가 작을수록 병행 제어가 복잡해지고 오버헤드가 증가하지만, 병행성 수준이 높아지고 데이터베이스 공유도가 높아진다.

     > **[로킹 규약]**
     >
     > 1) 트랜잭션 T가 공유 데이터 x를 접근하려면 먼저 lock(x)을 해야 한다.
     > 2) 공유 데이터를 사용한 T는 반드시 unlock(x)을 해야 한다.
     >
     > 3) 다른 트랜잭션에 의해 lock(x)가 실행되었다면, 트랜잭션 T는 lock(x)을 실행하지 못한다.
     >
     > 4) 트랜잭션 T가 lock(x) 한 것을 다른 트랜잭션이 unlock(x)할 수 없다.

     - 제약 

       1. 하나의 트랜잭션만이 공유 데이터 사용하는데, 읽기만 하는 경우에는 동시 접근 문제 없어 효율적이지 못함 -> *Solution = 2단계 로킹 규약(2PL)*

       2. 교착 상태(Dead Lock) 발생 가능

          여러 트랜잭션이 특정 데이터에 잠금 한채 다른 트랜잭션이 잠금을 수행한 데이터에 접근하려고 할 대 실행 못하고 서로 무한정 대기하는 상태

     - **2단계 로킹 규약 (Two-Phase Locking, 2PL)**

       - 각 트랜잭션의 lock과 unlock 요청을 2단계로 실시하는 방식.

         - 확장 단계(Growing phase) : 새로운 lock 연산만을 수행할 수 있고, unlock 연산은 수행할 수 없는 단계

         - 축소 단계(shrinking phase) : unlock 연산을 수행할 수 있고, lock연산은 수행할 수 없는 단계

       - 직렬성을 보장 BUT 여전히 lock 연산으로 인한 교착상태 예방 불가능

  2. 타임스탬프(Time Stamp)

     - 데이터에 접근하는 시간을 미리 정하여 정해진 시간의 순서대로 데이터에 접근하며 수행함.
     - 장점
       - 직렬가능성을 보장
       - 시간을 나눠 사용하기 때문에 교착상태가 발생하지 않음.
     - 단점
       - Rollback 발생률 높음.
       - 연쇄복귀를 초래할 수 있음.

  3. 낙관적 병행제어(Optimistic Concurrency Control)
     - 트랜잭션 수행 동안은 어떠한 검사도 하지 않고, 트랜잭션 종료 시에 일괄적으로 검사함
     - 트랜잭션 수행 동안 그 트랜잭션을 위해 유지되는 데이터 항복의 지역사본에 대해서만 갱신하며 트랜잭션 종료 시에 동시성을 위한 트랜잭션 직렬화가 검증되면 일시에 DB로 반영함.

   

  4. 다중 버전 병행제어(Multi-version Concurrency Control)
     - 하나의 데이터에 대해 여러 버전의 값을 유지하며 관리하는 기법
     - 충돌 발생 경우 연쇄 복귀 발생 가능성이 있음.

<br/>

### 02. 회복(Recovery)

- 장애 : DB 실행 오류 - (장애 발생시 회복작업의 단위 = 트랜잭션)

  1. 트랜잭션 장애
  2. 시스템 장애
  3. 미디어 장애

- 회복 : 트랜잭션 수행 중 장애로 손상된 DB를 이전 상태로 복구 시키는 작업.

  - 기본 원리 : 데이터 중복
    - 덤프(dump) : DB전체를 주기적으로 다른 저장장치에 복제.
    - 로그(log) : DB 변경될 때마다 변경 전/후의 값을 파일에 기록.

  1. Redo(재실행) : DB 자체가 손상 된 경우 가장 최근 복제복을 적재하고 그 이후 변경만을 로그를 이용해 재실행해 복원하는 것.
  2. Undo(취소) : DB 손상 없지만 변경 중이거나 변경된 내용의 신뢰성 잃어버렸을 때 로그를 이용해 변경들을 취소해 원래 상태로 복원하는 것.

- 회복 기법

  1. 로그 기반 회복

     1. 지연 갱신 회복 : 부분 완료까지 발생한 모든 변경 내용을 로그 팡리에만 저장하고 커밋 발생까지 저장을 지연하는 방식. (Redo)
     2. 즉시 갱신 회복 : 변경 내용을 로그 파일에 저장하고 즉시 데이터베이스에 반영하는 방식. (Undo, Redo)

  2. 검사점 기반 회복(체크포인트(Checkpoint) 회복)

     검사점 이전의 트랜잭션이 장애가 발생한 경우 해당 트랜잭션은 Redo하고(다시 실행) 검사점 이후의 트랜잭션이 장애가 발생한 경우 해당 트랜잭션을 Undo(취소)하는 방식.

  3. 그림자 페이징 회복

     현재 테이블은 주기억 장치, 그림자 페이지 테이블은 디스크에 저장하여 트랜잭션이 성공적으로 수행되는 경우 그림자 페이지 테이블을 삭제하고, 실패할 경우 그림자 페이지 테이블을 통해서 복구하는 방식

<br/>

### 03. 트랜잭션 격리 수준(Transaction Isolation Level)

- 트랜잭션에서 일관성 없는 데이터를 허용하도록 하는 수준

- 특정 트랜잭션이 다른 트랜잭션에 변경한 데이터를 볼 수 있도록 허용할지 말지를 결정하는 것

- 효율적인 Locking 방법을 위해 필요함.

- 동시성, 데이터 무결성과 연관됨(동시성 증가, 무결성 저하)

- 레벨 높아지면 트랜잭션간 고립 정도 높아짐. 성능 감소. 비용 증가.

  

- 종류

  1. **Read Uncommitted (레벨 0)**

     - SELECT 문장이 수행되는 동안 해당 데이터에 Shared Lock이 걸리지 않는 계층
     - 트랜잭션에 처리중이거나, 아직 Commit되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용함
     - *ex) 사용자1이 A라는 데이터를 B라는 데이터로 변경하는 동안 사용자2는 아직 완료되지 않은(Uncommitted) 트랜잭션이지만 데이터B를 읽을 수 있다*
     - 일관성을 유지하는 것이 불가능
     - Dirty Read 발생

  2. **Read Committed (레벨 1)**

     - SELECT 문장이 수행되는 동안 해당 데이터에 Shared Lock이 걸리는 계층
     - 트랜잭션이 수행되는 동안 다른 트랜잭션이 접근할 수 없어 대기하게 됨
     - Commit이 이루어진 트랜잭션만 조회 가능
     - *ex) 사용자1이 A라는 데이터를 B라는 데이터로 변경하는 동안 사용자2는 해당 데이터에 접근이 불가능함*
     - Non-Repeatable Read 발생

     

  3. **Repeatable Read (레벨 2)**

     - 트랜잭션이 완료될 때까지 SELECT 문장이 사용하는 모든 데이터에 Shared Lock이 걸리는 계층
     - 트랜잭션이 범위 내에서 조회한 데이터 내용이 항상 동일함을 보장함
     - 다른 사용자는 트랜잭션 영역에 해당되는 데이터에 대한 수정 불가능
     - Phantom Read 발생.

     

  4. **Serializable (레벨 3)**

     - 트랜잭션이 완료될 때까지 SELECT 문장이 사용하는 모든 데이터에 Shared Lock이 걸리는 계층
     - 완벽한 읽기 일관성 모드를 제공함
     - 다른 사용자는 트랜잭션 영역에 해당되는 데이터에 대한 수정 및 입력 불가능

     

- 낮은 단계 Isolation Level을 활용할 때 발생하는 현상들

  1. Dirty Read
     - 커밋되지 않은 수정중인 데이터를 다른 트랜잭션에서 읽을 수 있도록 허용할 때 발생하는 현상
     - 어떤 트랜잭션에서 아직 실행이 끝나지 않은 다른 트랜잭션에 의한 변경사항을 보게되는 경우

  2. Non-Repeatable Read
     - 한 트랜잭션에서 같은 쿼리를 두 번 수행할 때 그 사이에 다른 트랜잭션 값을 수정 또는 삭제하면서 두 쿼리의 결과가 상이하게 나타나는 일관성이 깨진 현상

  3. Phantom Read
     - 한 트랜잭션 안에서 일정 범위의 레코드를 두 번 이상 읽었을 때, 첫번째 쿼리에서 없던 레코드가 두번째 쿼리에서 나타나는 현상
     - 트랜잭션 도중 새로운 레코드 삽입을 허용하기 때문에 나타나는 현상임



<br/><br/><br/>

---------------

##### References

https://kosaf04pyh.tistory.com/201

https://velog.io/@thms200/SQL-vs-NoSQL

https://owlyr.tistory.com/20#bdcbaf9c-3ce5-44b6-b87a-0729a24f4123

https://velog.io/@bsjp400/Database-DB-%EC%A0%95%EA%B7%9C%ED%99%94-%EB%B9%84%EC%A0%95%EA%B7%9C%ED%99%94%EB%9E%80

https://coding-factory.tistory.com/226

https://rebro.kr/165?category=484170

https://gyoogle.dev/blog/

