[TOC]



# 프로세스

- 개념: **프로그램이 실행중인 상태**로 특정 메모리 공간에 코드가 적재되고 cpu가 명령어를 하나씩 수행하고 있는 상태.

  -single thread of execution

- memory layout of process

  - text : 실행 코드 부분
  - data : 전역변수, 정적 변수
  - heap : 메모리 할당 
  - stack : 지역변수, 매개변수 등 일시적으로 저장하는 영역
  - ![image-20211116233656942](C:\Users\YijinKim\AppData\Roaming\Typora\typora-user-images\image-20211116233656942.png)

- 프로세스 상태  ![image-20211116234058303](C:\Users\YijinKim\AppData\Roaming\Typora\typora-user-images\image-20211116234058303.png)

  - 생성, 실행 ,대기, 준비, 종료

- **PCB** (프로세스 제어 블록)

  os가 프로세스를 제어할때 상태 정보를 프로세스 제어 블록에 저장함.

  실행 제어를 위한 자료구조 -> 상태가 계속 변해도 해당 프로세스가 연속성 있게 실행되는 것처럼 보임.

  - 프로세스 상태
  - 프로그램 카운터
  - cpu 레지스터
  - cpu 스케줄링 정보
  - 메모리 관리 정보
  - 계정 정보
  - i/o 상태 정보, etc...

- 프로세스 생성

  1. 새로운 프로세스에 프로세스 식별자 할당
  2. 프로세스의 모든 구성 요소를 포함할 수 있는 주소공간과 pcb 공간 할당
  3. pcb 초기화(프로세스 상태, pc초기화, 자원 요청, 프로세스 제어 정보)
  4. 해당 큐에 삽입

- fork 명령어로 새로운 프로세스 생성

- 프로세스 종료

  - interrupt 신호 발생으로 프로세스 삭제 요청 or 시스템 호출 명령어로 삭제 요청
  - 정상 종료 : 프로세스가 os의 서비스 호출
  - 시간 초과: 명시된 전체 시간 초과 실행
  - 실패 : 파일 검색 실패, 입출력 명시된 횟수 초과,
  - 산술 오류, 메모리 부족, 액세스 위반,...
  - 부모가 자식 종료시킬 수 있는 방법 : 자식이 할당 자원 초과해 자원 사용/할당 작업 없을때

  abort 명령어로 프로세스 종료

- 프로세스 제거

  사용하던 자원을 시스템에 반환하고 시스템 리스트에서 해당 프로세스 없어짐

  pcb 회수 but 프로그램은 디스크에 저장됨. 프로세스만 종료된 것.

- 프로세스 중단/재시작

  중단 상태 추가하면 이벤트 발생 기다리면서 대기 상태가 되어 즉시 이벤트 발생시 실행상태로 바꿀수있다는 이점이 있음.



- 프로세스 우선순위

  프로세스 스케줄러는 pcb에 있는 우선순위 이용해 프로세스 처리함

  ex) 입출력 중심 프로세스 : 속도 느리면서 빠른 응답을 요구하는 단말기에 높은 우선순위/ 속도 빠른 디스크 입출력 프로세스에는 낮은 우선순위

  입출력 중심 프로세스는 프로세서를 짧게 자주 사용하게 하고, 프로세서 중심 프로세스는 프로세서를 길게 사용하되 사용 횟수를 줄여서 균형을 유지함.

- 프로세스의 문맥 교환(Context Switch)

  실행 중 프로세스에 인터럽트 발생되면 os가 다른 프로세스를 실행 상태로 바꾸고 제어 넘겨줘 문맥교환 발생

  스케줄러가 cpu에 다른 프로세스를 할당하려고 할때 현재 프로세스의 context를 pcb에 저장하고, 새로운 프로세스의 pcb로 교체함.

  dispatch, timeout, block 상태에서 일어남

  

# 스레드와 병행성

- 스레드

  -프로세스 시간을 할당하는 기본 단위. 하나 이상의 스레드가 해당 프로세스 내에서 코드를 실행함.

  -cpu 이용 기본 단위

  -구성 : id, pc, 레지스터 집합, 스택

  -같은 프로세스에 속한 다른 스레드와 코드, 데이터섹션, 파일,신호 같은 os자원 공유

  -다수의 제어 스레드 -> 프로세스는 동시에 하나 이상의 작업 수행 가능! (multithreaded process)

- 다중 스레드 프로그래밍 장점

  1. 응답성 : 일부가 긴 작업을 수행해도 프로그램의 수행이 계속되는 것을 허용
  2. 자원공유 : 스레드간 통신기법없이 협업 가능
  3. 경제성 : 프로세스 생성보다 스레드 활용이 경제적
  4. 규모 적응성: 각각의 스레드가 다른 프로세서에서 병렬로 수행하므로 규모 적응성 우수함.

- Multithreading

  - Single processor
    - 병행성 : 한 시점에 둘 중에 하나만 수행되고 있을 때 병행성을 이루었다고 한다 look 병렬적
    - 동시에 하듯이 수행하는 것,빠르게 프로그램 변경
  - multi core/processor
    - 병렬성 : 동시에 여러 스레드 실행/두 task 동시에 수행될때 코어의 병렬성 이루었다

- 다중 스레드 모델

  사용자 스레드를 위해 사용자 수준에서, 커널 스레드를 위해 커널 수준에서 제공

  스레드는 궁극적으로 cpu에서 실행되도록 커널 스레드에 매핑되야 함

- 스레드 라이브러리

  프로그래머에게 스레드 생성하고 관리하기 위한 api 제공

  1. 커널 지원없이 완전히 사용자 공간에서만 제공
  2. os에 의해 지원되는 커널 수준 라이브러리 구현



다수의 스레드 생성 전략

1. **비동기 스레딩(asynchronous threading):** 부모가 자식 스레드를 생성한 후 부모는 자신의 실행을 재개하여 부모와 자식 스레드가 서로 독립적으로 병행하게 실행되는 스레딩 방식 (다중 스레드 서버에서 주로 사용)
2. **동기 스레딩(synchronous threading):** 부모 스레드가 하나 이상의 자식 스레드를 생성하고 자식 스레드 모두가 종료할 때까지 기다렸다가 자신의 실행을 재개하는 스레딩 방식 (상당한 양의 데이터 공유를 수반)



암묵적 스레딩

- 컴파일러와 실행시간 라이브러리에게 넘겨주기
- 개발자는 병렬 작업만 식별하면 되고 라이브러리는 스레드 생성 및 관리에 대한 특정 세부 사항을 결정하면 된다.

스레드 풀

- 다중 스레드 프로세스 문제점 해결 방법
- 프로세스를 시작할 때 아예 일정한 수의 스레드들을 미리 풀로 만들어두는 것
- 이 스레드들은 평소에 하는 일 없이 일감을 기다리게 된다. 서버는 스레드를 생성하지 않고 요청을 받으면 대신 스레드 풀에 제출하고 추가 요청 대기를 재개한다. 풀에 사용 가능한 스레드가 있으면 깨어나고 요청이 즉시 서비스 된다. 스레드가 서비스를 완료하면 풀로 돌아가서 더 많은 작업을 기다린다.
- 장점
  - 새 스레드를 만들어 주기보다 기존 스레드로 서비스해 주는 것이 종종 더 빠르다.
  - 스레드 풀은 임의 시각에 존재할 스레드 개수에 제한을 둔다.
  - 태스크를 생성하는 방법을 태스크로부터 분리하면 태스크의 실행을 다르게 할 수 있다.

스레드의 상태 변화

- 준비, 실행, 대기, 종료
- 스레드가 대기상태로 변할때 프로세스를 대기상태로 만들지 않음.

스레드 제어 블록 TCB

​	실행 상태, 스케줄링 정보, 계정 정보, 포인터, ...

​	pcb는 tcb의 리스트를 가리킨다



### Reference

https://wonit.tistory.com/90?category=740633

https://imbf.github.io/computer-science(cs)/2020/10/14/Threads-and-Concurrency.html

# CPU 스케쥴링

# 동기화

# 교착 상태
