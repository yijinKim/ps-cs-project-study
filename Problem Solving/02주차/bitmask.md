## 비트마스크

정수의 이진수 표현을 자료구조로 쓰는 기법

- 장점

  1) 빠른 수행시간 : O(1), 비트의 개수만큼 원소를 다룰 수 있기 때문에 연산 횟수 클수록 차이 커짐.
  2) 짧은 코드 : 집합 연산자들을 비트연산자로 간결한 작성 가능
  3) 적은 메모리 사용량 : 10bit 이진수 하나로 2^10가지의 경우 표현 가능 -> 메모리 측면 효율적
     더 많은 데이터 미리 계산해서 저장 가능한 장점.

- 연산자

  1. AND : 둘 다
  2. OR : 둘 중 하나라도
  3. XOR : 둘중 하나만 1이면 1, 둘다 1/0이면 0
  4. NOT : 반대의 경우
  5. shift : 왼쪽(<<)/오른쪽(>>) 이동

- 연산자 활용

  1. 원소 추가  : n=3일때 1을 3만큼 왼쪽으로 밀어주면 1000, 0010 OR 1000 = 1010

     ```python
     n = 3
     print(bin(0b0010 | (1 << n)))  # 0b1010
     ```

  2. 원소 삭제  : n=3일때 1을 3만큼 왼쪽으로 밀어주면 1000, (~1000) = 0111, 0111 AND 1000 = 0010

     ```python
     n = 3
     print(bin(0b0010 & ~(1 << n)))  # 0b0010
     ```

  3. 원소 조회  : n=3일때 1을 3만큼 왼쪽으로 밀어주면 1000, 1010 AND 1000 = 1000

     ```python
     n = 3
     print(bin(0b1010 & (1 << n)))  # 0b1000
     ```

  4. 원소 토글(XOR)  : n=3일때 1을 3만큼 왼쪽으로 밀어주면 1000, 1010 XOR 1000 = 0010

     ```python
     n = 3
     print(bin(0b1010 ^ (1 << n)))  # 0b10
     ```

     

- 주의점
  1. 비교 연산자보다 낮은 우선순위
  2. 오버플로우(overflow)

- 집합 구현

  하나의 비트가 하나의 원소로, 비트가 켜져있으면 집합에 포함, 꺼져있으면 불포함의 의미.

  N비트 정수 변수로 N개의 원소 갖는 집합의 부분집합 표현 가능

  0-9일 경우, 공집합 : 0, 전체집합 (1<<10) - 1

  ex) {a,b,c,d} 총 4개의 원소에서 존재하면 1, 아니면 0
  {a}라는 부분집합은 1000(2) = 8 로 표현, {b,c} 는 0110(2) = 6으로 표현

  

  이진수 연산 : https://www.acmicpc.net/problem/12813

  집합 : https://www.acmicpc.net/problem/11723

  

  ### 참고

  0에서 출발하므로 0에 방문표시 1을 놓고 시작.

  sol(1,1) 0->1

  0->1로 간 경우이다. 2,3을 방문할수있다

  

  sol(2,11) 1->2

  0,1을 방문하고 먼저 2를 방문

  

  sol(3,111) 2->3

  0,1,2을 방문하고 3 방문

  

  sol(3,11) 1->3

  0,1을 방문하고 3 방문

  

  sol(2,1011) 3->2

  0,1,3을 방문하고 2를 방문

  

  0->2를 방문했을때

  sol(2,1) 0->2
  sol(1,101) 2->1
  sol(3,111) 1->3
  sol(3,101) 2->3
  sol(1,1101) 3->1

  0->3 방문했을때

  sol(3,1) 0->3
  sol(1,1001) 3->1
  sol(2,1011) 1->2
  sol(2,1001) 3->2
  sol(1,1101) 2->1

  

  

  

  ------

  ### Reference

  https://studyandwrite.tistory.com/325

  https://shoark7.github.io/programming/algorithm/introduction-to-tsp-and-solve-with-exhasutive-search#3b

  

  